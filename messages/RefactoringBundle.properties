field.0.is.already.defined.in.the.1=字段{0}已经定义在{1}.
members.to.form.interface=成员形成接口(&B)
remove.parameter.0.no.longer.used=移除不再使用的参数''{0}''
would.you.like.to.replace.default.constructor.of.0.with.factory.method=你想用一个工厂方法替换{0}的默认构造器吗？
replace.button=替换
inline.class.elements.header=类内联
field.0.is.not.static=字段{0}不是静态的.{1}重构是只支持静态成员.
invert.boolean.title=逆布尔
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter=已有一个{0}在{1}中。它会与重命名的参数冲突。
no.superclass.name.specified=未指定超类名称
move.single.class.or.package.name.label=移动{0}{1}
moveInstanceMethod.select.an.instance.parameter=选择一个实例参数: (&I)
no.interface.name.specified=未指定接口名称
extract.method.title=提取方法
encapsulate.fields.field.column.name=字段
safe.delete.comment.occurences.header=事件发现在评论、字符串和非标文件{0}.这些事件不会改变
instance.initializer.description=把类{0}的初始器实例化
the.following.problems.were.found=发现以下问题:
renaming.0.1.to.2=将{0}{1}重命名为{2}
ExtractSuperClass.superclass=超类
class.0.does.not.have.inheritors=类{0}没有继承者.
changeSignature.exception.caller.chooser=选择要传递新异常的方法
rename.variables.title=重命名变量
inline.parameter.error.varargs=不支持内联可变参数
extractIncludeFile.name=提取包含文件
javadoc.move=移动 (&M)
rename.tests.with.the.following.names.to=重命名测试具有以下名称:
migration.type.column.header=类型
move.class.to.inner.command.name=移动{0},{1}
type.cook.drop.obsolete.casts=删除废弃转换 (&D)
method.0.will.implement.method.of.the.base.class=方法{0}将实现基类{1}的一个方法。
the.file.will.be.copied.to.this.directory=文件将被复制到此目录
entity.name.form=形式
choose.the.ones.you.want.to.be.deleted=选择你想要的被删除.
change.signature.feel.lucky=感到幸运(
constructor.being.refactored.is.used.in.initializer.of.0=构造函数用于初始化器被重构的{0}.非静态内部类厂{1}不能用在这个上下文.产生的代码不需要编译.
inline.method.command=内联方法{0}
error.title=错误
migration.package=包
rename.tests.title=重命名测试
method.duplicates.method.label=方法{0}
replacing.inheritance.with.delegation=替换继承与代表团
classes.to.push.down.members.to=类来压低成员{0}
replace.method.duplicates.scope.chooser.title=指定{0}范围
fields.to.be.refactored.should.belong.to.the.same.class=重构的字段应该属于同一个类.
encapsulate.fields.title=封装字段
copy.files.clone.file.0=克隆文件{0}
cancel.button=取消 (&N)
refactoring.extract.method.dialog.output.variables=输出变量
references.found.in.generated.code=引用在生成的代码中找到
migration.class=类
changeSignature.cannot.resolve.return.type=返回类型''{0}''不能解决,继续吗?
replace.all.occurences=替换所有的匹配项({0}匹配项) (&A)
no.button=否 (&N)
rename.inheritors=重命名继承者 (&I)
move.classes.destination.to.package=包装(dg
push.down.will.delete.members=推动成员下来将导致它们被删除.你想创建一个新的子类?
column.name.any.var=任何var
error.wrong.caret.position.anonymous=光标应该定位在被重构的匿名类中
visibility.private=私有 (&V)
type.migration.rerun.button.text=返回类型迁移 (&R)
column.name.type=类型
replace.inheritance.with.delegation.title=用委派替换继承
encapsulate.fields.setter.exists=那已经是一个方法{0},{1}有别于setter由返回类型只有.
references.in.code.to.0.1=在代码中引用到{0}{1}
selected.expression.has.void.type=选定的表达式有空隙类型.
members.to.be.pulled.up=成员被拉起(&B)
changeSignature.no.type.for.parameter=指定一个类型给参数''{0}''
current.class=当前类
changeSignature.name.prompt=名称: (&N)
encapsulate.fields.getter.exists=那已经是一个方法不同于{0}{1}的getter只返回类型.
usages.detected.title=发现使用
target.0.is.not.accessible.from.1=目标{0}是不可以从{1}.
select.refactoring.title=选择重构
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=参数初始化包含{0},但并非所有调用的方法是,在它的阶级.
process.methods.duplicates.title=过程方法复制的{2}({0},{1})
variable.of.type=类型的变量: (&T)
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=不支持移动方法当方法是一个继承层次结构的一部分
rename.directory.button.text=重命名目录 (&D)
inline.parameter.command.name=内联参数{0}
move.specified.directories=移动指定的目录
field.description=字段{0}
encapsulate.fields.fields.to.be.encapsulated=字段封装
renames.project=重命名项目
items.to.be.deleted=项已被删除
class.is.never.used=类从未使用
members.to.form.superclass=超类的成员 (&B)
members.to.be.pushed.down.panel.title=成员被下移 (&B)
changeSignature.refactoring.name=更改签名
cannot.introduce.field.in.interface=不能提取字段在接口
inline.command=内联{0}
file.already.exist=文件{0}已经存在
variable.is.accessed.for.writing.and.used.with.inlined=另一个变量"{0}"定义配合使用内联一个.
introduce.field.title=提取常量
add.parameters.for.fields=添加参数字段:
refactoring.extract.method.dialog.empty=空
search.in.comments.and.strings=在注释和字符中搜索 (&C)
safe.delete.title=安全删除
migration.move.up.button=向上移动
moving.directories.command=移动目录中...
rename.title=重命名
type.migration.include.action.text=包含 (&I)
turn.refs.to.super.command=更换使用{0}和{1}
add.parameters.for.fields.to.constructors=添加参数字段构造函数:
inline.title=内联
type.cook.command=泛型
introduce.constant.field.of.type=常数(静态final字段)的类型(&T):
move.class.to.inner.move.to.self.error=不允许移动类到自身
visibility.combo.title=可见: (&V)
inline.to.anonymous.no.inheritors=类有子类不能内联
refactoring.is.not.supported.for.local.and.jsp.classes=重构不支持局部和JSP类.
replace.inheritance.from=替换委派继承从: (&R)
to.rename=重命名sdf
make.0.static=把{0}静态化
selected.block.should.represent.a.set.of.statements.or.an.expression=选块应该代表一组语句或表达式
invert.boolean.wrong.type=该方法的返回类型或类型的变量是重构应该是布尔
do.not.show.this.message.in.the.future=以后不再显示此消息 (&D)
class.does.not.have.base.classes.or.interfaces=类{0}没有基类或接口.
replace.inheritance.with.delegation.command=替换继承与代表团在{0}
directory.0.already.contains.1.named.2=目录已经包含了{0}{1}命名为"{2}"
invert.boolean.name.of.inverted.element=名字倒 {0}(&N):
encapsulate.fields.no.fields.selected=没有字段可选择
copy.handler.clone.class=克隆类
inline.included.file.title=内联包括文件
member.info.implements.0=实现{0}
refactoring.extract.method.dialog.signature.preview=签名预览
interface.does.not.have.base.interfaces=接口{0}没有基本接口.
copy.class.copy.0.1=复制{0}{1}
migration.entry.new.name=新名称:
replace.constructor.with.factory.method=用工厂方法替换构造器
caller.chooser.looking.for.callers=寻找打电话...
move.current.directory=移动当前 (&C)
move.members.members.to.be.moved.border.title=成员需要移动(静态唯一的)(
boolean.method.result=布尔方法的结果
progress.text=寻找使用中...
introduce.parameter.title=提取字段
annotate.field.as.nonnls.checkbox=注释字段作为 @NonNls (&F)
variable.does.not.have.an.initializer=变量{0}没有初始化.
a.package.local.class.0.will.no.longer.be.accessible.from.1=封装本地类{0}将不可以在{1}
changeSignature.default.value.column=默认值
make.abstract=抽象化
do.you.wish.to.continue=要继续吗?
change.signature.leave.blank.default.value=留空(&B)
locate.caret.inside.a.method=定位插入符号在一个成员.
there.is.already.a.0.in.1=已存在一个{0}在{1}中
inline.the.contents.include.prompt=内联内容"{0}"?
unknown.expression.type=未知的表达式类型.
replace.with.method.call.does.not.work.for.constructors=替换为方法调用不工作为构造函数
method.has.an.empty.body=方法有一个空的{0}身体.
changeSignature.no.return.type=未指定返回类型
type.cook.report=项目泛型: {0}, 转换已移除: {1}
there.are.unused.methods.that.override.methods.you.delete=有未使用的方法,覆盖方法你删除.
detecting.possible.conflicts=检测可能的冲突...
inline.method.border.title=内联
class.has.been.successfully.created=已成功创建类{0}.
extractSuperInterface.interface=接口
delegation.panel.delegate.via.overloading.method=代表通过重载方法(
anonymousToInner.no.inner.class.name=需指定类名
rename.tests=重命名测试 (&E)
instances.casted.to.java.lang.object=实例转换为java.lang.Object
inline.field.border.title=内联
delete.title=删除
caller.chooser.caller.method=调用方法
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=插入符号应该定位在一个类来拉成员.
there.are.going.to.be.multiple.destination.files.with.the.same.name=有多个目标文件具有相同的名称。
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=光标应该定位在被重构的类/方法/字段中
the.file.will.be.moved.to.this.directory=文件将被移到此目录
javadoc.copy=复制 (&C)
member.info.extends.0=扩展{0}
change.signature.use.selected.value=使用所选值(v)
 (&V)
directories.and.all.references.to.package.will.be.renamed=是否只重命名整个包或目录{0}?
inline.parameter.refactoring=内联参数
move.to.inner.duplicate.inner.class=类{0}已包含一个名为{1}的内部类
all.references.and.remove.super.class=内联所有引用并删除类 (&A)
no.class.name.specified=未指定类名称
selected.block.should.represent.an.expression=选块应该代表一个表达式.
cannot.create.directory=无法创建目录
inline.to.anonymous.no.multiple.interfaces=实现多个接口的类不能被内联
make.method.static.title=把方法静态化
rename.directories.command.name=重命名目录
extractSuper.extract=提取{0} (&X)
inline.to.anonymous.refactoring=内联到匿名类
method.0.is.overridden.by.1=方法{0}被{1}重写。
rename.0.and.its.usages.to=重命名{0}和它的用法:
extract.to.directory=提取目录: (&D)
declare.static.checkbox=声明静态 (&S)
member.is.already.static=成员已经是静态的.
declaration.s.to.be.generified=声明(s)是泛型{0}
move.to.different.language=目标类{2}有不同的语言比{0}{1}
method.column=方法
copy.files.to.directory.label=到目录: (&D)asdf
invert.boolean.refs.to.invert=引用是倒{0}
variable.is.never.used=变量{0}从未使用
introduce.parameter.convert.lambda=转换为 lambda (&C)
signature.preview.border.title=签名预览
error.wrong.caret.position.method.or.class.name=光标应该定位在被重构的方法或类的名字中
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=所有的引用类型参数都未知类型
rename.inheritors.title=重命名继承者
javadoc.as.is=保留原样 (&A)
replace.instance.qualifiers.with.class.references=替换实例与类引用限定符
inline.field.command=内联场{0}
extract.superclass.elements.header=提取超类成员到目录
superclass.name=超级类名称: (&S)
move.packages.elements.header=包将被移动至{0}
used.by.0=被{0}使用
rename.constructor.parameters.with.the.following.names.to=重命名参数具有以下名称:
inner.class.0.is.already.defined.in.class.1=内部类{0}已被定义在类{1}中.无论如何都继续?
inline.to.anonymous.name.label=类{0}
delete.anyway.button=无论如何都删除 (&D)
replace.default.constructor.with.factory.method=用工厂方法替换默认的构造器
encapsulate.fields.protected.radio=保护 (&T)
rename.original.interface.to=重命名原始接口到:
move.inner.class.to.another.class=移动内部类{0}到另一个类 (&M)
changeSignature.cannot.resolve.parameter.type=类型"{0}"参数"{1}"不能解决继续吗?
rename.project.handler.title=重命名项目(&P)
delete.variable.declaration=删除变量声明 (&D)
changeSignature.no.default.value=新参数"{0}"已被添加.指定一个默认值被用于该方法的所有现有的电话.
refactoring.introduce.variable.scope.error=与现有的变量名冲突
inline.vars.elements.header=变量以内联
superclass.cannot.be.extracted.from.an.enum=不能从一个枚举中提取超类.
selected.block.contains.invocation.of.another.class.constructor=选块包含调用另一个类的构造函数.
changeSignature.propagate.exceptions.title=传递异常... (&X)
encapsulate.fields.accessors.visibility.border.title=访问器可见
move.members.elements.header=要移动的成员
cannot.introduce.variable.in.super.constructor.call=不能提取变量在超级构造函数调用
refactoring.introduce.name.error=错误的名称
use.interface.superclass.in.instanceof=使用接口/超类的实例
replace.constructor.with.factory.method.title=用工厂方法替换构造器
migration.edit.button=编辑...
usageView.doAction=执行重构 (&D)
file.already.exist.title=提取包含文件
inline.to.anonymous.border.title=内联
target.destination.folder=目标目录: (&D)
New.name.of.method.is.not.java.identifier=方法的新名称不是Java标识符
functional.interface.broken=函数表达式要求功能界面准确的一种方法
replace.all.occurences.checkbox=替换所有的匹配项 (&A)
choose.destination.package=选择目的包
refactoring.introduce.name.used.error=这个名字已经使用
pullUp.command=从{0}向上移动成员
uses.0=使用{0}
migration.dialog.ok.button.text=运行
rename.module.title=重命名模块 (&M)
inline.to.anonymous.no.superclass.and.interface=有超类和实现了接口的类不能被内联
type.cook.leave.object.parameterized.types.raw=离开对象参数化类型生(&L)
changing.signature.of.0=改变签名的{0}
dont.support.inner.classes=重构无效：{0}不支持内部类
replace.constructor.with.factory.target.fq.name=在(完全限定名称):
entity.name.inheritor=继承者
turnRefsToSuper.change.usages.to=更改{0}的使用到: (&C)
column.name.default.value=默认值
package.for.new.superclass=新超类的包: (&P)
selected.expression.cannot.be.a.constant.initializer=选定的表达式不能初始化一个常数.
migration.move.down.button=向下移动
move.class.refactoring.cannot.be.applied.to.anonymous.classes=移动类重构不能应用于匿名类
interface.member.dependency.required.by.interfaces=所要求的 {0,选择,1#interface|2#interfaces}
rename.constructor.parameters.title=重命名构造器参数
parameter.description=参数{0}
variable.is.referenced.in.multiple.files=变量{0}在多个文件中引用
references.in.code=引用代码{0}
move.method.is.not.supported.for.constructors=移动方法不支持构造函数
inlined.method.implements.method.from.0=内联方法实现方法从{0}
method.0.will.override.a.method.of.the.base.class=方法{0}将重写基类{1}的一个方法。
delegation.panel.method.calls.label=方法调用：
changeSignature.parameters.wont.propagate=递归传播的参数的更改不会被执行
delegation.panel.modify.radio=修改 (&M)
move.file.0=移动文件{0}
renaming.command.name=重命名{0}
the.caret.should.be.positioned.inside.a.class.to.push.members.from=插入符号应该定位在一个类来推动成员
package.occurs.in.package.prefixes.of.the.following.source.folders.n=包{0}发生在包前缀下列源文件夹:
migration.map.name.prompt=地图的名字:
migration.new.name.column.header=新名字
error.in.injected.lang.prefix.suffix=选定的{0}在被重构文件的只读文件中
inline.parameter.confirmation=内联参数"{0}"与初始化"{1}"?
this.reference.only.and.keep.super.class=这个仅供参考并保持内联的超类(&K)
field.0.will.hide.field.1.of.the.base.class=字段{0}将隐藏基类 {2} 的字段{1}.
refactoring.extract.method.dialog.method.name=方法名称:
create.directory=创建目录
expression.result=表达式结果
inline.field.field.name.label=字段{0}
method.0.will.hide.method.of.the.base.class=方法{0}将隐藏基类{1}的此方法。
move.class.to.inner.nonstatic.error=不允许移动类到非静态内部类
error.out.of.project.element=选定的{0}不在项目中
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=使用访问器即使字段是可访问的(
source.and.destination.classes.should.be.different=源和目标类应该不同
introduce.constant.enum.cb=提取为枚举常量 (&E)
migration.remove.button=移除
pass.outer.class.instance.as.parameter=使外部类实例作为一个参数 (&O)
choose.destination.class=选择目的类
replace.constructor.0.with.a.factory.method=用一个工厂方法替换构造器{0}
source.folder.0.has.package.prefix.1=源文件夹{0}已包前缀"{1}"包装"{2}"不能被创造的.
extractSuper.rename.original.class.to=重命名原始类到: (&R)
error.wrong.caret.position.class=光标应该定位在被重构的类中
changeSignature.vararg.not.last=可变参数应该在方法签名的最后
changeSignature.wrong.return.type=错误的返回类型:''{0}''
refactoring.cannot.be.performed=重构不能执行
rename.not.supported=操作不被支持.
replace.inheritance.with.delegation.elements.header=替换继承与代表团
variable.has.no.initializer=变量{0}没有初始化.
changeClassSignature.refactoring.name=更改类签名
class.description=类{0}
edit.migration.entry.title=编辑 类/包 迁移说明
inline.field.elements.header=场内联
changeSignature.not.throwable.type=错误的异常类型''{0}''，应继承java.lang.Throwable
invocations.to.be.inlined=调用内联{0}
interface.0.does.not.have.inheritors=接口{0}没有继承者.
rename.variables.with.the.following.names.to=重命名变量具有以下名称:
inline.to.anonymous.command.name=内联类{0}
move.inner.class.to.upper.level=移动内部类{0}上水平(
warning.title=警告
rename.bound.forms.title=重命名绑定形式
encapsulate.fields.set.access.checkbox=设置访问(
do.not.replace=不要替换 (&N)
directory.description=目录{0}
the.field.should.be.declared.in.a.class=应在类中声明该字段.
move.members.title=移动成员
problems.detected.title=发现问题
inline.field.title=内联领域
cannot.move.inner.class.0.into.itself=不能移动内部类{0}到本身.
refactoring.is.not.supported.for.jsp.classes=重构不支持JSP类.
cannot.extract.selected.elements.into.include.file=不能提取选定的元素包含文件.
migration.no.usages.found.in.the.project=没有发现在项目使用
inner.class.exists=名为''{0}''的内部类已经定义在类''{1}''中
cannot.make.abstract.method.static=不能把抽象方法静态化
references.found.in.code=引用代码中发现
inline.method.elements.header=方法内联
generate.getter.for.delegated.component=为委派成员生成getter (&G)
method.0.is.not.static=方法{0}不是静态的。{1}重构只支持静态成员。
class.does.not.have.implicit.default.constructor=类{0}没有隐式的默认构造函数.
move.inner.class.to.be.moved=类移动
type.migration.migrate.button.text=迁移 (&M)
convert.to.instance.method.title=转换为实例方法
make.static.description.label=使{0}{1}静态化
this.reference.only.and.keep.the.field=内联这只引用和保持字段(&K)
member.column=成员
usageView.need.reRun=不能执行重构操作.有改变用途后的代码已经被发现.请,再执行使用搜索.
do.you.want.to.process.overriding.methods.with.covariant.return.type=你想methodswith协变过程覆盖返回类型?
error.cannot.resolve=不能解决{0}
anonymousToInner.parameters.panel.border.title=构造函数的参数
extract.include.file.title=提取包含文件
please.enter.a.valid.target.package.name=请输入一个有效的目标包名称
declare.generated.annotations=生成注释(&G)
select.target.directory=选择目标目录
there.are.no.variables.that.have.reference.type=有没有具有引用类型的变量
no.destination.class.specified=未指定目标类
error.incorrect.data=不正确的数据
instances.upcasted.to.java.lang.object.found=实例upcasted到java . lang.对象发现
move.method.this.parameter.label=为''{0}.this''参数选择一个名称
visibility.escalate=升级 (&E)
error.wrong.caret.position.constructor=光标应该定位在被重构的构造函数中
inline.method.method.label=方法{0}
local.variable.description=局部变量{0}
add.object.as.a.parameter.with.name=添加对象作为参数名称:(
replace.this.code.fragment.and.change.signature=方法的签名将被更改为{0}
cannot.find.or.create.destination.directory=无法找到或创建目标目录
migration.add.button=添加...
copy.handler.copy.class=复制类
information.title=信息
type.of.the.selected.expression.cannot.be.determined=类型的选定的表达式不能确定.
unable.to.start.type.migration=无法启动类型迁移
type.cook.preserve.raw.arrays=保存原始数组(&A)
extract.superclass.title=提取超类
keep.abstract.column.header=保持抽象
move.specified.packages=移动指定的包
migration.map.set.migration.maps=迁移映射
encapsulate.fields.command.name=封装字段在{0}
changeSignature.wrong.type.for.exception=异常的错误类型:''{0}''
class.0.not.found=类{0}未找到.
error.wrong.caret.position.method.or.local.name=光标应该定位在被重构的元素的名字中
replace.fields.used.in.expressions.with.their.getters=替换字段用于表情和他们的getter方法
invalid.expression.context=无效的表达式上下文.
migration.entry.class=类
replace.method.duplicates.scope.chooser.message=分析范围
this.reference.only.and.keep.the.class=内联这只引用和保持类(&K)
method.0.is.already.defined.in.the.1=方法{0}已定义在{1}.
extract.superclass.command.name=提取超类{0}从{1}
rerun.safe.delete=重新运行安全删除 (&R)
all.candidate.variables.have.unknown.types=所有的候选变量都未知类型
ok.button=确定
refactoring.introduce.selection.error=使用选定的元素不能执行重构
variable.is.never.used.before.modification=修改之前从未使用变量{0}
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=所有引用类型参数的类型,不是在项目
preview.usages.to.be.changed=预览要改变的用法(P)
 (&P)
class.0.already.exists=类{0}已存在
rename.project=重命名项目
statusBar.noUsages=未找到匹配项
extractSuper.rename.original.class=重命名原始类并在可能的情况下使用{0} (&E)
no.target.directory.specified=未指定目标目录
extract.superclass.from=从中提取超类:
entity.name.constructor.parameter=参数
entity.name.test=测试
declare.varargs.checkbox=宣布可变参数(
these.package.prefixes.will.be.changed=这些包前缀将被改变.
to.refactor=重构saf
extract.chained.constructor.checkbox=提取链接构造函数 (&C)
move.instance.method.title=移动实例方法
migration.old.name.column.header=旧名称
references.to.0.to.be.replaced.with.references.to.1=引用"{0}"被引用为"{1}"
this.invocation.only.and.keep.the.method=此调用内联方法(只有和保持
inline.local.variable.prompt=内联局部变量''{0}''？
moving.local.classes.is.not.supported=不支持移动局部类。
introduce.constant.title=提取常量
no.members.selected=没有成员选择
encapsulate.fields..package.local.radio=局部包 (&C)
introduced.variable.will.conflict.with.0=引入的变量与{0}冲突
rename.inheritors.with.the.following.names.to=重命名继承者具有以下名称:
instances.of.0.upcasted.to.1.were.found=实例的{0},{1}upcasted被发现.如果你继续下去,他们将被显示在一个单独的找到选项卡.
fields.0.are.not.accessible=字段{0}不可以从{1}
usageView.usagesText=使用
invalid.target.package.name.default.package=无法移动类至默认包
encapsulate.fields.encapsulate.border.title=封装
occurrences.found.in.comments.strings.non.java.files.and.generated.code=出现在评论,发现字符串,无代码文件和生成的代码
rename.implementation.class.to=重命名实现类:
inner.class.name=内部类名称 (&I):
all.references.and.remove.the.field=内联所有引用并删除字段 (&A)
copy.files.clone.title=克隆
changeClassSignature.no.type.parameters=这个类不能有类型参数
analyze.and.replace.usages=分析和替换使用
column.name.name=名称:
copy.handler.copy.files.directories=复制文件/目录
replace.all.fields=替换所有字段 (&R)
factory.method.name.label=工厂方法名称：
anonymousToInner.refactoring.name=转换匿名为内部
destination.directory.does.not.correspond.to.any.package=目标目录不对应于任何包
unselect.all.button=取消选择所有 (&U)
introduce.field.static.field.of.type=类型的静态字段: (&T)
multiple.directories.correspond.to.package=多个目录对应方案
inner.class.0.is.not.static=内部类{0}非静态,{1}重构只支持静态成员.
migration.title=迁移
current.method.radio=当前方法 (&M)
move.method.enter.a.valid.name.for.parameter=请输入一个有效的参数名称
move.inner.class.command=移动内部类{0}
rename.directory.command.name=重命名目录
occurences.to.be.migrated=事件被迁移的{0}
add.object.as.a.parameter.to.constructors.with.name=添加对象作为一个参数的构造函数与名称:(
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=已经有一个{0}.它将冲突与一个介绍参数
rename.directories=重命名全部 (&A)
encapsulate.fields.fields.to.encapsulate.border.title=字段来封装
variable.has.no.dominating.definition=无法找到一个定义内联.
synthetic.jsp.class.is.referenced.in.the.method=合成的jsp类是引用的方法
no.initializer.present.for.the.field=没有初始化器出席现场
move.files.to.directory.label=到目录:asdf
constructor.description=构造函数{0}
visibility.public=公共 (&B)
usageView.tabText=重构预览
error.wrong.caret.position.method=光标应该定位在被重构的方法中
move.members.move.members.from.label=移动成员:
interface.name.prompt=接口名称: (&I)
introduce.parameter.to.method=提取参数对象... (_J)
method.is.not.a.constructor=方法是不是构造器。
all.references.and.remove.the.class=内联所有引用并删除类 (&A)
visibility.border.title=可见
path.completion.shortcut=使用{0}的路径完成
generify.title=泛型
introduce.functional.parameter.title=提取函数参数
entity.name.variable=变量
unsupported.refs.found=不支持的参考文献发现在{0}文件
press.escape.to.remove.the.highlighting=按逃到删除高亮显示
encapsulate.fields.private.radio=私有 (&I)
inner.classes.cannot.have.static.members=内部类不能有静态成员.
introduce.selection.error=不能用选定的元素执行重构
pull.up.members.to=把成员的{0}:
copy.files.copy.specified.directories.label=复制指定的目录
type.cook.produce.wildcard.types=产生通配符类型(&W)
visibility.as.is=保留原样 (&A)
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter=已有一个{0}在{1}中。它会与新的参数冲突。
rename.variables=重命名变量 (&V)
introducing.variable.may.break.code.logic=引入变量可能打破代码逻辑。
move.specified.classes=移动指定的类
to.delete.with.usage.search=删除(使用搜索)dsdf
introduce.variable.title=提取变量
cannot.move=无法移动
replace.temp.with.query.title=取代临时与查询
encapsulate.fields.get.access.checkbox=获得(
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=所有这些目录会被感动,所有引用到{0}将被改变.
migration.dialog.title=包和类迁移
introduce.parameter.elements.header=增加参数到一个方法
package.for.original.interface=原始接口的包: (&P)
migration.entry.old.name=旧名称:
refactoring.introduceVariable=提取变量重构
introduce.parameter.command=提取参数{0}
error.wrong.caret.position.symbol.to.refactor=光标应该定位在被重构的符号中
migration.entry.package=包
cannot.perform.refactoring=不能执行重构
select.all.button=全选 (&A)
field.declaration.radio=字段声明 (&D)
changeSignature.parameter.caller.chooser=选择要传递新参数的方法
encapsulate.fields..encapsulated.fields.visibility.border.title=封装字段的可见性
error.wrong.caret.position.method.or.variable.name=光标应该定位在被重构的方法或变量的名字中
move.package.refactoring.cannot.be.applied.to.default.package=移动包重构不能用于默认包
name.for.extracted.include.file=提取包含文件名称(默认扩展: {0})(&N)
destination.package=目的包: (&P)
push.down.members.elements.header=压低成员来自
error.wrong.caret.position.local.or.expression.name=光标应该定位在被重构的局部变量或表达式的名字中
all.invocations.and.remove.the.method=内联所有调用和删除方法(
error.wrong.name.input=错误的名称:{0}
visibility.protected=保护 (&O)
changeSignature.exceptions.wont.propagate=递归传播的异常的更改不会被执行
changeSignature.return.type.prompt=返回类型: (&T)
this.member.does.not.seem.to.belong.to.any.class=此成员似乎不属于任何类.
anonymousToInner.class.name.label.text=类名:
field.exists=字段名称{0}已经存在于类''{1}''中,继续吗?
safe.delete.command=删除中{0}
move.directory.to.another.source.root=移动目录{0}的另一个源根(
no.parameter.name.specified=未指定参数名称
copy.files.copy.specified.mixed.label=复制指定的文件和目录
refactoring.extract.method.dialog.parameters=参数
move.instance.method.elements.header=移动实例方法
replace.fields.inaccessible.in.usage.context=替换上下文没有使用的字段 (&I)
inline.method.title=内联方法
inlined.method.overrides.method.from.0=从{0}内联方法重写方法
copy.files.new.name.label=新名字: (&N)
push.members.down.title=向下移动成员
move.specified.files=移动指定的文件
move.files.elements.header=文件移动到{0}
pushed.members.will.not.be.visible.from.certain.call.sites=推动会员将不可见从特定调用地点.
copy.files.copy.file.0=复制文件{0}
move.title=移动
all.invocations.in.project=所有调用在项目(
changeSignature.wrong.type.for.parameter=的参数''{1}''错误类型:''{0}''
refactoring.introduce.placing.error=不能提取{0}变量
package.for.original.class=原始类的包: (&P)
do.you.wish.to.ignore.them.and.continue=要忽略它们并继续吗?
the.language.for.selected.elements.has.no.associated.file.type=语言为选中的元素没有相关的文件类型
searching.for.variables=搜索变量中...
migration.package.with.subpackages=包和子包
file.description=文件{0}
search.for.references=搜索引用 (&F)
directory.chooser.hide.non.existent.checkBox.text=隐藏不存在的 (&H)
all.references.and.remove.the.local=内联和删除的所有引用的变量(&A)
parameters.border.title=参数
migration.new.button=新...
extract.interface.from=提取接口从:
this.method=这种方法
refactoring.extract.method.dialog.title=提取方法
create.class.command=创建类{0}
move.classes.destination.make.inner=使内部类(
field.name=字段名称 (&F):
initialize.in.border.title=初始化在
convertToInstanceMethod.method.is.not.static=不能执行重构方法,{0}不是静态的
error.wrong.caret.position.local.name=光标应该定位在被重构的局部变量的名字中
copy.files.copy.directory.0=复制目录{0}
process.duplicates.title=过程重复的{0},{1}
anonymousToInner.make.class.static.checkbox.text=使类静态化 (&S)
all.candidate.variables.have.types.not.in.project=所有的候选人不变量类型的项目
introduce.constant.introduce.to.class=提取参数到方法:
changeSignature.exceptions.panel.border.title=异常
variable.is.accessed.for.writing=变量"{0}"可写.
rename.forms.with.the.following.names.to=重命名形式具有以下名称:
anonymous.class.text=匿名类
inline.to.anonymous.no.abstract=抽象类不能被内联
interface.has.been.successfully.created=已成功创建接口{0}.
replace.method.code.duplicates.title=替换重复代码
there.are.multiple.exit.points.in.the.selected.code.fragment=选定的代码片段有多个出口点。
rename.bound.forms=重命名绑定形式(
package.does.not.exist=包{0}不存在,是否创建它?
caller.chooser.callee.method=调用方法
move.inner.to.upper.level.title=移动内部,上水平
only.fields.variables.of.methods.of.valid.type.can.be.considered=仅字段，变量，方法参数或有效的类型的方法可以考虑。
inline.parameter.replace.with.local.checkbox=替换为局部变量(e)
 (&E)
superclass.cannot.be.extracted.from.an.interface=不能从一个接口中提取超类.
rename.parameters.hierarchy=重命名参数在层次结构(
renamed.class.will.hide.0.in.1=重命名类将隐藏{0}在{1}
replace.all.occurrences.of.expression.0.occurrences=替换所有的匹配项({0})(&A)
inline.parameter.error.hierarchy=内联参数不支持当方法是一个继承层次结构的一部分
parameter.of.type=类型的参数: (&T)
no.selection=没有选择.
package.for.new.interface=包为新界面: (&P)
ignore.button=忽略
select.source.root.chooser.title=选择根源代码
move.classes.move.to.another.source.folder=搬到另一个源文件夹(&F)
declare.static.pass.fields.checkbox=声明 &static (通过域作为参数)
class.constructors.radio=类构造函数 (&C)
invert.0.1=转化的{0}{1}及其用法
class.0.does.not.exist=类{0}不存在.您想创建它吗?
continue.button=继续 (&C)
rename.project.action.title=重命名项目...
parameter.name.prompt=参数名称: (&M)
encapsulate.fields.options.border.title=选项
press.the.do.migrate.button=按下"迁移"按钮底部的搜索结果panelto迁移使用迁移地图"{0}"
preview.button=预览 (&P)
references.in.code.to.elements.from.migration.map=在代码元素的引用从移民地图"{0}"{1}
extract.interface.title=提取接口
copy.class.clone.0.1=克隆{0}{1}
directory.0.already.contains.a.file.named.1=目录{0}已经包含一个文件命名为"{1}"
class.does.not.exist.in.the.project=类不存在在这个项目.你想创建它吗?
move.directories=移动全部 (&A)
move.specified.elements=移动指定的元素
readonly.occurences.found=在只读文件中找到匹配项
changeSignature.no.type.for.exception=指定一个类型给异常
references.to.be.changed=引用是改变了{0}
move.specified.classes.to=移动指定的类到:
package.description=包{0}
move.classes.elements.header=类将被移动至{0}
declare.final=声明final (&F)
type.migration.exclude.action.text=排除 (&E)
move.method.is.not.supported.for.generic.classes=移动方法不支持泛型类
class.0.is.not.accessible.from.target.1=类{0}是不可以从目标{1}.
automatic.renamer.rename.to.column=重命名为
changeClassSignature.class.label.text=更改{0}的签名
introduce.field.field.of.type=类型的字段: (&T)
inline.local.variable.definition.prompt=内联局部变量''{0}''定义？
no.new.name.specified=未指定新名称
default.visibility.border.title=缺省可见
use.super.references.prompt=在这个阶段{0}可以分析用途的{1},换成用法的{2}在可能的情况下.是否要继续?
declare.folded.parameters=褶皱参数(
copy,handler.clone.files.directories=克隆文件/目录
no.usages.can.be.replaced=没有用途的{0}可以替换使用{1}
invalid.target.package.name.specified=指定的目标包名称无效
field.0.is.never.used=字段{0}从未使用过
unused.overriding.methods.title=未使用重写方法
members.to.be.moved.should.belong.to.the.same.class=要移动的成员应该属于同一类。
method.description=方法{0}
copy.files.clone.directory.0=克隆目录{0}
what.would.you.like.to.do=你想做什么?
comments.elements.header=事件发现在评论、字符串和非标文件{0}
select.migration.map=选择移民地图:
use.interface.where.possible.title=在可能处使用接口
replace.default.constructor.of.0.with.a.factory.method=用一个工厂方法替换{0}的默认构造器
move.classes.command=移动的{0},{1}包
the.caret.should.be.positioned.on.the.included.file.to.inline=插入符号应放置在包含文件的引用内联
replace.fragment=替换片段
changeSignature.propagate.parameters.title=传递参数...(&G)
references.in.code.to.0=在代码中引用到{0}
please.enter.a.valid.name.for.inverted.element=请输入一个有效的名字倒{0}
there.is.already.a.0.it.will.conflict.with.the.renamed.1=已经有一个{0}.它将冲突与更名为{1}
class.name.prompt=类名: (&N)
replace.this.code.fragment=这段代码替换吗?
refactoring.introduce.context.error=不能执行重构在这个上下文
type.cook.perform.exhaustive.search=执行彻底的搜索 (&E)
move.instance.method.command=移动实例方法
delegate.members=委派成员 (&B)
extract.subclass.command=提取子类
use.variable.initializer.to.initialize.parameter=使用变量初始器到初始参数 (&I)
inline.variable.title=内联变量
method.does.not.have.a.body=方法{0}没有方法体。
usages.detected=发现使用
move.method.is.not.supported.for.0=移动实例方法不支持{0}
move.enum.constant.cb=如果可能，移动为枚举常数 (&E)
select.target.directory.description=将此目录中创建文件
enter.new.project.name=输入新项目的名称:
remove.duplicates.command=删除重复的
remove.include.prompt=包括文件不再使用.删除它吗?
rename.package.button.text=重命名包 (&P)
move.package.to.another.package=移动包"{0}"到另一个包(
occurrences.found.in.comments.strings.and.non.java.files=事件发现在评论、字符串和非标文件
attempting.to.delete.targets.node.text=试图删除
error.wrong.caret.position.symbol.to.rename=光标应该定位在被重构的符号中
convertToInstanceMethod.no.parameters.with.reference.type=有没有具有引用类型的参数
encapsulate.fields.refactoring.cannot.be.applied.to.interface=封装字段重构不能应用到接口
static.initializer.description=把类{0}的初始器静态化
changeClassSignature.parameters.panel.border.title=参数
edit.migration.map.title=编辑迁移地图
field.0.is.not.accessible=字段{0}是不可以从{1}
extract.interface.command.name=提取接口{0}从{1}
name.prompt=名称 (&N)
renaming.something=重命名一些
cannot.replace.temp.with.query.in.interface=不能取代临时与查询界面.
convert.local.to.field.title=将局部转换为字段
extract.method.control.flow.analysis.failed=代码包含语法错误。无法执行必要的分析。
migration.map.description.label=图描述:
error.cannot.be.renamed=此元素不能被重命名.
pull.members.up.title=把成员向上移动
choose.destination.directory=选择目标目录
view.usages=查看使用 (&V)
copy.files.copy.title=复制
replace.write.access.occurrences=替换白名单匹配项 (&L)
rename.directory.title=重命名目录 (&D)
inline.method.checking.tail.calls.progress=检查尾调用用法
constructor.cannot.be.made.static=构造函数不能是静态的.
setup.method.radio=设置方法(
initializer.for.variable.cannot.be.a.constant.initializer=初始化变量的{0}不能初始化一个常数.
copy.files.copy.specified.files.label=复制指定的文件
rename.current.directory=重命名当前 (&C)
retry.command=重试
refactor.button=重构 (&R)
there.are.multiple.output.values.for.the.selected.code.fragment=选定的代码片段有多个输出值。
search.for.text.occurrences=搜索文本匹配项 (&T)
selection.does.not.form.a.fragment.for.extraction=选择不会形成一个片段提取.
delete.include.command=删除{0}
visibility.package.local=局部包 (&K)
turnRefsToSuper.use.superclass.in.instanceof=使用接口/超类在实例 (&U)
make.static.command=把{0}静态化
cannot.move.package.into.itself=无法移动包到其自身
extract.method.method.panel.border=方法
local.will.be.hidden.renamed=重命名字段将隐藏{ 0 }
move.directory.0=移动目录{0}
no.field.name.specified=未指定字段名称
push.members.from.0.down.label=推动成员从{0}下来
move.nonstatic.class.from.jsp.not.supported=非静态类移动从JSP页面不支持.
yes.button=是 (&Y)
move.directories.elements.header=目录移动到{0}
